[tool.poetry]
name = "pykiso"
version = "0.16.0"
description = "Embedded integration testing framework."
authors = ["Sebastian Fischer <sebastian.fischer@de.bosch.com>"]
license = "Eclipse Public License - v 2.0"
readme = "README.md"
homepage = "https://pypi.org/project/pykiso/"
repository = "https://github.com/eclipse/kiso-testing"
documentation = "https://kiso-testing.readthedocs.io/en/latest/"
packages = [
    { include = "pykiso", from = "src" }
]
keywords = [
    "testing",
    "integration testing",
    "framework",
    "testing framework",
]
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: Eclipse Public License 2.0 (EPL-2.0)",
    "Operating System :: Unix",
    "Operating System :: POSIX",
    "Operating System :: Microsoft :: Windows",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.7",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: Implementation :: CPython",
    "Topic :: Utilities",
]

[tool.poetry.dependencies]
python = "^3.7"
PyYAML = "*"
pylink-square = "^0.12.0"
pyserial = "*"
python-can = {extras = ["pcan"], version = "^4.0.0"}
python-uds = {git = "https://github.com/BKaDamien/python-uds.git", rev = "2.0.2"}
PyVISA = "*"
PyVISA-py = "*"
robotframework = "3.2.2"
unittest-xml-reporting = "*"
click = "*"
MarkupSafe = "~2.0"
poethepoet = "^0.13.1"

[tool.poetry.dev-dependencies]
auto-changelog = "0.5.3"
black = { version = "^21.12b0", allow-prereleases = true }
bump2version = "*"
coverage = "*"
invoke = "*"
pdbpp = "*"
pre-commit = "*"
pylint = "*"
pytest = "*"
pytest-cov = "*"
pytest-mock = "*"
Sphinx = "*"
sphinx-rtd-theme = "*"
sphinxcontrib-programoutput = "*"
sphinx-autodoc-typehints = "*"
poethepoet = "^0.13.1"

[tool.poetry.scripts]
pykiso = 'pykiso.cli:main'
instrument-control = 'pykiso.lib.auxiliaries.instrument_control_auxiliary.instrument_control_cli:main'

[tool.pytest.ini_options]
testpaths = [
    "tests/"
]
addopts = """\
    --verbose \
    --log-level=INFO \
    --cov=./src \
    --cov-report=html \
    --cov-report html:./tests/coverage_report.html \
    --cov-config=.coveragerc \
    --ignore=tests/test_acroname_usb_auxiliary.py \
    --ignore=tests/test_robot_acroname.py \
"""

[tool.coverage.run]
omit = [
    "*/tests/*",
    "*/examples/*",
    "*/setup.py",
    "*/tasks.py",
    "*/src/pykiso/__main__.py",
    "*__init__.py",
]

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.poe.env]
log="killme.log"


[tool.poe.tasks]

test={shell=""" 
import os   
import platform
pty = platform.system() == "Linux"
os.system("pytest")
""",interpreter="python"}

clean_docs={ shell = """
from pathlib import Path
import glob
import shutil
import os
ROOT_DIR = os.getcwd()
DOCS_DIR = ROOT_DIR+  "/docs"
DOCS_BUILD_DIR = DOCS_DIR+  "/_build"
def delete_folders(folder_name: str, root_dir: str = None) -> None:
    if isinstance(folder_name, Path):
        folder_name = str(folder_name)
    search_path = os.path.join(root_dir, folder_name) if root_dir else folder_name

    for folder in glob.iglob(search_path, recursive=True):
        if Path(folder).is_dir():
            shutil.rmtree(folder)

delete_folders(DOCS_BUILD_DIR)
""",interpreter="python"} 

clean_build= {shell= """
import os 
import glob
from pathlib import Path
from typing import Union
ROOT_DIR = os.getcwd()

def _delete_files(
    file_name: Union[str, Path], root_dir: Union[str, Path] = None
) -> None:
    '''Delete files which matches given pattern.
    :param file_name: file name as unix shell style wildcard.
      Examples: "../../Tools/*/*.gif"
    :param root_dir: root folder to start search from (optional)
    :raise OsError: when file cant be removed
    .. note:: Using the “**” pattern in large directory trees may consume an inordinate amount of time.
    '''
    if isinstance(file_name, Path):
        file_name = str(file_name)
    search_path = os.path.join(root_dir, file_name) if root_dir else file_name

    for file in glob.iglob(search_path, recursive=True):
        if Path(file).is_file():
            os.remove(file)


def _delete_folders(folder_name: str, root_dir: str = None) -> None:
    '''Delete folders which matches given pattern.
    :param folder_name: folder name as unix shell style wildcard.
      Examples: "**/*__pycache__" for all folders named "__pycache__"
    :param root_dir: root folder to start search from (optional)
    .. note:: Using the “**” pattern in large directory trees may consume an inordinate amount of time.
    '''
    if isinstance(folder_name, Path):
        folder_name = str(folder_name)
    search_path = os.path.join(root_dir, folder_name) if root_dir else folder_name

    for folder in glob.iglob(search_path, recursive=True):
        if Path(folder).is_dir():
            shutil.rmtree(folder)

_delete_folders("build", root_dir=ROOT_DIR)
_delete_folders("dist", root_dir=ROOT_DIR)
_delete_folders(".eggs", root_dir=ROOT_DIR)
_delete_folders("**/*.egg-info", root_dir=ROOT_DIR)
_delete_files("**/*.egg", root_dir=ROOT_DIR)
""",interpreter="python"}

clean_python={shell= """
import os 
import glob
from pathlib import Path
from typing import Union
import shutil
ROOT_DIR = os.getcwd()

def _delete_files(
    file_name: Union[str, Path], root_dir: Union[str, Path] = None
) -> None:
    if isinstance(file_name, Path):
        file_name = str(file_name)
    search_path = os.path.join(root_dir, file_name) if root_dir else file_name

    for file in glob.iglob(search_path, recursive=True):
        if Path(file).is_file():
            os.remove(file)


def _delete_folders(folder_name: str, root_dir: str = None) -> None:
    if isinstance(folder_name, Path):
        folder_name = str(folder_name)
    search_path = os.path.join(root_dir, folder_name) if root_dir else folder_name

    for folder in glob.iglob(search_path, recursive=True):
        if Path(folder).is_dir():
            shutil.rmtree(folder)
            
_delete_files("run.py", root_dir=ROOT_DIR)
_delete_files("**/*.pyc", root_dir=ROOT_DIR)
_delete_files("**/*.pyo", root_dir=ROOT_DIR)
_delete_files("**/*~", root_dir=ROOT_DIR)
_delete_folders("**/*__pycache__", root_dir=ROOT_DIR)


""",interpreter="python"}

docs=["clean_docs",{shell="""
import os
import webbrowser
from pathlib import Path

ROOT_DIR =  os.getcwd()
DOCS_DIR = ROOT_DIR  +"/docs"
DOCS_BUILD_DIR = DOCS_DIR  +"/_build"
DOCS_INDEX = DOCS_BUILD_DIR  +"/index.html"
os.system("sphinx-build -b html {} {}".format(DOCS_DIR, DOCS_BUILD_DIR))

webbrowser.open(DOCS_INDEX)


""",interpreter="python"}]

changelog={shell="""
import os
os.system("auto-changelog -u --template templates/changelog/changelog.jinja2")
""",interpreter="python"}

clean_tests={shell= """
import os 
import glob
import shutil
from pathlib import Path
from typing import Union
ROOT_DIR = os.getcwd()
TEST_DIR = ROOT_DIR+  "/tests"
COVERAGE_DIR = TEST_DIR + "/coverage_report.html"

def _delete_files(
    file_name: Union[str, Path], root_dir: Union[str, Path] = None
) -> None:
    '''Delete files which matches given pattern.
    :param file_name: file name as unix shell style wildcard.
      Examples: "../../Tools/*/*.gif"
    :param root_dir: root folder to start search from (optional)
    :raise OsError: when file cant be removed
    .. note:: Using the “**” pattern in large directory trees may consume an inordinate amount of time.
    '''

    if isinstance(file_name, Path):
        file_name = str(file_name)
    search_path = os.path.join(root_dir, file_name) if root_dir else file_name

    for file in glob.iglob(search_path, recursive=True):
        if Path(file).is_file():
            os.remove(file)


def _delete_folders(folder_name: str, root_dir: str = None) -> None:
    '''Delete folders which matches given pattern.
    :param folder_name: folder name as unix shell style wildcard.
      Examples: "**/*__pycache__" for all folders named "__pycache__"
    :param root_dir: root folder to start search from (optional)
    .. note:: Using the “**” pattern in large directory trees may consume an inordinate amount of time.
    '''
    if isinstance(folder_name, Path):
        folder_name = str(folder_name)
    search_path = os.path.join(root_dir, folder_name) if root_dir else folder_name

    for folder in glob.iglob(search_path, recursive=True):
        if Path(folder).is_dir():
            shutil.rmtree(folder)

_delete_folders("**/\\.pytest_cache", root_dir=ROOT_DIR)
_delete_files(".coverage", root_dir=ROOT_DIR)
shutil.rmtree(COVERAGE_DIR, ignore_errors=True)


""",interpreter="python"}

clean=["clean_build", "clean_python", "clean_tests", "clean_docs"]

    

update_copyright={shell="""
import glob
import re
import pathlib
COPYRIGHT='''\
##########################################################################
# Copyright (c) 2010-2022 Robert Bosch GmbH
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0.
#
# SPDX-License-Identifier: EPL-2.0
##########################################################################

'''

def update_copyright():
    p = pathlib.Path(".")
    files = p.glob("**/*.py")

    # RST docs copyright notice
    pat = r':Copyright:.*?SPDX-License-Identifier: EPL-[0-9.]\\s'
    cp_doc_pat = re.compile(pat, re.MULTILINE + re.DOTALL)
    # comment copyright notice
    pat = r'#*\\s*#\\s*Copyright.*?#\\s*SPDX-License-Identifier: EPL-[0-9.]+\\s*#*\\s+'
    cp_com_pat = re.compile(pat, re.MULTILINE + re.DOTALL)

    for pyf in files:
        with open(pyf, "r+", encoding="utf8") as f:
            text = f.read()
            text = cp_doc_pat.sub("", text, count=1)
            text = cp_com_pat.sub("", text, count=1)
            text = COPYRIGHT + text
            f.seek(0)
            f.write(text)
            f.truncate()

update_copyright()
""",interpreter="python"}


    [tool.poe.tasks.run]
    ignore_fail = true
    help = "Run the example of pykiso."
    args=[{name="level",default="INFO",options = ["-l", "--level"]}]
    sequence=[{shell="""
import os
script='''
import os
import glob
from pathlib import Path
from typing import Union
import sys

ROOT_DIR = os.getcwd()


def _delete_files(
    file_name: Union[str, Path], root_dir: Union[str, Path] = None
) -> None:
    if isinstance(file_name, Path):
        file_name = str(file_name)
    search_path = os.path.join(root_dir, file_name) if root_dir else file_name

    for file in glob.iglob(search_path, recursive=True):
        if Path(file).is_file():
            os.remove(file)


def run(level):
    _delete_files("killme.log", root_dir=ROOT_DIR)
    os.system(f"pykiso -c examples/dummy.yaml --log-level={level} -l killme.log")


if __name__ == "__main__":
    globals()[sys.argv[1]](sys.argv[2])
'''
with open("run.py", "w", encoding="utf8") as f:
    f.write(script)

    """,    interpreter="python"},
    {cmd="python run.py run $level"},
    {shell="""
import os 
import glob
from pathlib import Path
from typing import Union
import shutil
ROOT_DIR = os.getcwd()

def _delete_files(
    file_name: Union[str, Path], root_dir: Union[str, Path] = None
) -> None:
    if isinstance(file_name, Path):
        file_name = str(file_name)
    search_path = os.path.join(root_dir, file_name) if root_dir else file_name

    for file in glob.iglob(search_path, recursive=True):
        if Path(file).is_file():
            os.remove(file)
_delete_files("run.py", root_dir=ROOT_DIR)

    """,interpreter="python"}]
